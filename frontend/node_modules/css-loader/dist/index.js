"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loader;
<<<<<<< HEAD
var _postcss = _interopRequireDefault(require("postcss"));
var _package = _interopRequireDefault(require("postcss/package.json"));
var _semver = require("semver");
var _options = _interopRequireDefault(require("./options.json"));
var _plugins = require("./plugins");
var _utils = require("./utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
=======

var _schemaUtils = _interopRequireDefault(require("schema-utils"));

var _postcss = _interopRequireDefault(require("postcss"));

var _package = _interopRequireDefault(require("postcss/package.json"));

var _postcssModulesLocalByDefault = _interopRequireDefault(require("postcss-modules-local-by-default"));

var _postcssModulesExtractImports = _interopRequireDefault(require("postcss-modules-extract-imports"));

var _postcssModulesScope = _interopRequireDefault(require("postcss-modules-scope"));

var _postcssModulesValues = _interopRequireDefault(require("postcss-modules-values"));

var _loaderUtils = require("loader-utils");

var _normalizePath = _interopRequireDefault(require("normalize-path"));

var _options = _interopRequireDefault(require("./options.json"));

var _plugins = require("./plugins");

var _utils = require("./utils");

var _Warning = _interopRequireDefault(require("./Warning"));

var _CssSyntaxError = _interopRequireDefault(require("./CssSyntaxError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

>>>>>>> 491790fa3284842aea531bfa9d2fd819794b4f37
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
<<<<<<< HEAD

async function loader(content, map, meta) {
  const rawOptions = this.getOptions(_options.default);
  const callback = this.async();
  if (this._compiler && this._compiler.options && this._compiler.options.experiments && this._compiler.options.experiments.css && this._module && (this._module.type === "css" || this._module.type === "css/auto" || this._module.type === "css/global" || this._module.type === "css/module")) {
    this.emitWarning(new Error('You can\'t use `experiments.css` (`experiments.futureDefaults` enable built-in CSS support by default) and `css-loader` together, please set `experiments.css` to `false` or set `{ type: "javascript/auto" }` for rules with `css-loader` in your webpack config (now css-loader does nothing).'));
    callback(null, content, map, meta);
    return;
  }
  let options;
  try {
    options = (0, _utils.normalizeOptions)(rawOptions, this);
  } catch (error) {
    callback(error);
    return;
  }
  const plugins = [];
  const replacements = [];
  const exports = [];
  if ((0, _utils.shouldUseModulesPlugins)(options)) {
    plugins.push(...(0, _utils.getModulesPlugins)(options, this));
  }
  const importPluginImports = [];
  const importPluginApi = [];
  let isSupportAbsoluteURL = false;

  // TODO enable by default in the next major release
  if (this._compilation && this._compilation.options && this._compilation.options.experiments && this._compilation.options.experiments.buildHttp) {
    isSupportAbsoluteURL = true;
  }
  const isSupportDataURL = options.esModule && Boolean("fsStartTime" in this._compiler);
  if ((0, _utils.shouldUseImportPlugin)(options)) {
    plugins.push((0, _plugins.importParser)({
      isSupportAbsoluteURL: false,
      isSupportDataURL: false,
      isCSSStyleSheet: options.exportType === "css-style-sheet",
      loaderContext: this,
      imports: importPluginImports,
      api: importPluginApi,
      filter: options.import.filter,
      urlHandler: url => (0, _utils.stringifyRequest)(this, (0, _utils.combineRequests)((0, _utils.getPreRequester)(this)(options.importLoaders), url))
    }));
  }
  const urlPluginImports = [];
  if ((0, _utils.shouldUseURLPlugin)(options)) {
    const needToResolveURL = !options.esModule;
    plugins.push((0, _plugins.urlParser)({
      isSupportAbsoluteURL,
      isSupportDataURL,
      imports: urlPluginImports,
      replacements,
      context: this.context,
      rootContext: this.rootContext,
      filter: (0, _utils.getFilter)(options.url.filter, this.resourcePath),
      resolver: needToResolveURL ? this.getResolve({
        mainFiles: [],
        extensions: []
      }) :
      // eslint-disable-next-line no-undefined
      undefined,
      urlHandler: url => (0, _utils.stringifyRequest)(this, url)
      // Support data urls as input in new URL added in webpack@5.38.0
    }));
  }
  const icssPluginImports = [];
  const icssPluginApi = [];
  const needToUseIcssPlugin = (0, _utils.shouldUseIcssPlugin)(options);
  if (needToUseIcssPlugin) {
    plugins.push((0, _plugins.icssParser)({
      loaderContext: this,
      imports: icssPluginImports,
      api: icssPluginApi,
      replacements,
      exports,
      urlHandler: url => (0, _utils.stringifyRequest)(this, (0, _utils.combineRequests)((0, _utils.getPreRequester)(this)(options.importLoaders), url))
    }));
  }

  // Reuse CSS AST (PostCSS AST e.g 'postcss-loader') to avoid reparsing
=======
function loader(content, map, meta) {
  const options = (0, _loaderUtils.getOptions)(this) || {};
  (0, _schemaUtils.default)(_options.default, options, 'CSS Loader');
  const callback = this.async();
  const sourceMap = options.sourceMap || false;
  /* eslint-disable no-param-reassign */

  if (sourceMap) {
    if (map) {
      // Some loader emit source map as string
      // Strip any JSON XSSI avoidance prefix from the string (as documented in the source maps specification), and then parse the string as JSON.
      if (typeof map === 'string') {
        map = JSON.parse(map.replace(/^\)]}'[^\n]*\n/, ''));
      } // Source maps should use forward slash because it is URLs (https://github.com/mozilla/source-map/issues/91)
      // We should normalize path because previous loaders like `sass-loader` using backslash when generate source map


      if (map.file) {
        map.file = (0, _normalizePath.default)(map.file);
      }

      if (map.sourceRoot) {
        map.sourceRoot = (0, _normalizePath.default)(map.sourceRoot);
      }

      if (map.sources) {
        map.sources = map.sources.map(source => (0, _normalizePath.default)(source));
      }
    }
  } else {
    // Some loaders (example `"postcss-loader": "1.x.x"`) always generates source map, we should remove it
    map = null;
  }
  /* eslint-enable no-param-reassign */
  // Reuse CSS AST (PostCSS AST e.g 'postcss-loader') to avoid reparsing


>>>>>>> 491790fa3284842aea531bfa9d2fd819794b4f37
  if (meta) {
    const {
      ast
    } = meta;
<<<<<<< HEAD
    if (ast && ast.type === "postcss" && (0, _semver.satisfies)(ast.version, `^${_package.default.version}`)) {
=======

    if (ast && ast.type === 'postcss' && ast.version === _package.default.version) {
>>>>>>> 491790fa3284842aea531bfa9d2fd819794b4f37
      // eslint-disable-next-line no-param-reassign
      content = ast.root;
    }
  }
<<<<<<< HEAD
  const {
    resourcePath
  } = this;
  let result;
  try {
    result = await (0, _postcss.default)(plugins).process(content, {
      hideNothingWarning: true,
      from: resourcePath,
      to: resourcePath,
      map: options.sourceMap ? {
        prev: map ? (0, _utils.normalizeSourceMap)(map, resourcePath) : null,
        inline: false,
        annotation: false
      } : false
    });
  } catch (error) {
    if (error.file) {
      this.addDependency(error.file);
    }
    callback(error.name === "CssSyntaxError" ? (0, _utils.syntaxErrorFactory)(error) : error);
    return;
  }
  for (const warning of result.warnings()) {
    this.emitWarning((0, _utils.warningFactory)(warning));
  }
  const imports = [].concat(icssPluginImports.sort(_utils.sort)).concat(importPluginImports.sort(_utils.sort)).concat(urlPluginImports.sort(_utils.sort));
  const api = [].concat(importPluginApi.sort(_utils.sort)).concat(icssPluginApi.sort(_utils.sort));
  if (options.modules.exportOnlyLocals !== true) {
    imports.unshift({
      type: "api_import",
      importName: "___CSS_LOADER_API_IMPORT___",
      url: (0, _utils.stringifyRequest)(this, require.resolve("./runtime/api"))
    });
    if (options.sourceMap) {
      imports.unshift({
        importName: "___CSS_LOADER_API_SOURCEMAP_IMPORT___",
        url: (0, _utils.stringifyRequest)(this, require.resolve("./runtime/sourceMaps"))
      });
    } else {
      imports.unshift({
        importName: "___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___",
        url: (0, _utils.stringifyRequest)(this, require.resolve("./runtime/noSourceMaps"))
      });
    }
  }
  let isTemplateLiteralSupported = false;
  if (
  // eslint-disable-next-line no-underscore-dangle
  this._compilation &&
  // eslint-disable-next-line no-underscore-dangle
  this._compilation.options &&
  // eslint-disable-next-line no-underscore-dangle
  this._compilation.options.output &&
  // eslint-disable-next-line no-underscore-dangle
  this._compilation.options.output.environment &&
  // eslint-disable-next-line no-underscore-dangle
  this._compilation.options.output.environment.templateLiteral) {
    isTemplateLiteralSupported = true;
  }
  const importCode = (0, _utils.getImportCode)(imports, options);
  let moduleCode;
  try {
    moduleCode = (0, _utils.getModuleCode)(result, api, replacements, options, isTemplateLiteralSupported, this);
  } catch (error) {
    callback(error);
    return;
  }
  const exportCode = (0, _utils.getExportCode)(exports, replacements, needToUseIcssPlugin, options, isTemplateLiteralSupported);
  callback(null, `${importCode}${moduleCode}${exportCode}`);
=======

  const plugins = [];

  if (options.modules) {
    const loaderContext = this;
    const mode = typeof options.modules === 'boolean' ? 'local' : options.modules;
    plugins.push(_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({
      mode
    }), (0, _postcssModulesExtractImports.default)(), (0, _postcssModulesScope.default)({
      generateScopedName: function generateScopedName(exportName) {
        const localIdentName = options.localIdentName || '[hash:base64]';
        const customGetLocalIdent = options.getLocalIdent || _utils.getLocalIdent;
        return customGetLocalIdent(loaderContext, localIdentName, exportName, {
          regExp: options.localIdentRegExp,
          hashPrefix: options.hashPrefix || '',
          context: options.context
        });
      }
    }));
  }

  if (options.import !== false) {
    plugins.push((0, _plugins.importParser)({
      filter: (0, _utils.getFilter)(options.import, this.resourcePath)
    }));
  }

  if (options.url !== false) {
    plugins.push((0, _plugins.urlParser)({
      filter: (0, _utils.getFilter)(options.url, this.resourcePath, value => (0, _loaderUtils.isUrlRequest)(value))
    }));
  }

  plugins.push((0, _plugins.icssParser)());
  (0, _postcss.default)(plugins).process(content, {
    from: (0, _loaderUtils.getRemainingRequest)(this).split('!').pop(),
    to: (0, _loaderUtils.getCurrentRequest)(this).split('!').pop(),
    map: options.sourceMap ? {
      prev: map,
      inline: false,
      annotation: false
    } : null
  }).then(result => {
    result.warnings().forEach(warning => this.emitWarning(new _Warning.default(warning)));
    const messages = result.messages || []; // Run other loader (`postcss-loader`, `sass-loader` and etc) for importing CSS

    const importUrlPrefix = (0, _utils.getImportPrefix)(this, options.importLoaders); // Prepare replacer to change from `___CSS_LOADER_IMPORT___INDEX___` to `require('./file.css').locals`

    const importItemReplacer = placeholder => {
      const match = _utils.placholderRegExps.importItem.exec(placeholder);

      const idx = Number(match[1]);
      const message = messages.find( // eslint-disable-next-line no-shadow
      message => message.type === 'icss-import' && message.item && message.item.index === idx);

      if (!message) {
        return placeholder;
      }

      const {
        item
      } = message;
      const importUrl = importUrlPrefix + (0, _loaderUtils.urlToRequest)(item.url);

      if (options.exportOnlyLocals) {
        return `" + require(${(0, _loaderUtils.stringifyRequest)(this, importUrl)})[${JSON.stringify(item.export)}] + "`;
      }

      return `" + require(${(0, _loaderUtils.stringifyRequest)(this, importUrl)}).locals[${JSON.stringify(item.export)}] + "`;
    };

    const exports = messages.filter(message => message.type === 'export').reduce((accumulator, message) => {
      const {
        key,
        value
      } = message.item;
      let valueAsString = JSON.stringify(value);
      valueAsString = valueAsString.replace(_utils.placholderRegExps.importItemG, importItemReplacer);

      function addEntry(k) {
        accumulator.push(`\t${JSON.stringify(k)}: ${valueAsString}`);
      }

      let targetKey;

      switch (options.camelCase) {
        case true:
          addEntry(key);
          targetKey = (0, _utils.camelCase)(key);

          if (targetKey !== key) {
            addEntry(targetKey);
          }

          break;

        case 'dashes':
          addEntry(key);
          targetKey = (0, _utils.dashesCamelCase)(key);

          if (targetKey !== key) {
            addEntry(targetKey);
          }

          break;

        case 'only':
          addEntry((0, _utils.camelCase)(key));
          break;

        case 'dashesOnly':
          addEntry((0, _utils.dashesCamelCase)(key));
          break;

        default:
          addEntry(key);
          break;
      }

      return accumulator;
    }, []);

    if (options.exportOnlyLocals) {
      return callback(null, exports.length > 0 ? `module.exports = {\n${exports.join(',\n')}\n};` : '');
    }

    const imports = messages.filter(message => message.type === 'import').map(message => {
      const {
        url
      } = message.item;
      const media = message.item.media || '';

      if (!(0, _loaderUtils.isUrlRequest)(url)) {
        return `exports.push([module.id, ${JSON.stringify(`@import url(${url});`)}, ${JSON.stringify(media)}]);`;
      }

      const importUrl = importUrlPrefix + (0, _loaderUtils.urlToRequest)(url);
      return `exports.i(require(${(0, _loaderUtils.stringifyRequest)(this, importUrl)}), ${JSON.stringify(media)});`;
    }, this);
    let cssAsString = JSON.stringify(result.css).replace(_utils.placholderRegExps.importItemG, importItemReplacer); // Helper for ensuring valid CSS strings from requires

    let hasUrlEscapeHelper = false;
    messages.filter(message => message.type === 'url').forEach(message => {
      if (!hasUrlEscapeHelper) {
        imports.push(`var urlEscape = require(${(0, _loaderUtils.stringifyRequest)(this, require.resolve('./runtime/url-escape.js'))});`);
        hasUrlEscapeHelper = true;
      }

      const {
        item
      } = message;
      const {
        url,
        placeholder,
        needQuotes
      } = item; // Remove `#hash` and `?#hash` from `require`

      const [normalizedUrl, singleQuery, hashValue] = url.split(/(\?)?#/);
      const hash = singleQuery || hashValue ? `"${singleQuery ? '?' : ''}${hashValue ? `#${hashValue}` : ''}"` : '';
      imports.push(`var ${placeholder} = urlEscape(require(${(0, _loaderUtils.stringifyRequest)(this, (0, _loaderUtils.urlToRequest)(normalizedUrl))})${hash ? ` + ${hash}` : ''}${needQuotes ? ', true' : ''});`);
      cssAsString = cssAsString.replace(new RegExp(placeholder, 'g'), () => `" + ${placeholder} + "`);
    });
    const runtimeCode = `exports = module.exports = require(${(0, _loaderUtils.stringifyRequest)(this, require.resolve('./runtime/api'))})(${!!sourceMap});\n`;
    const importCode = imports.length > 0 ? `// Imports\n${imports.join('\n')}\n\n` : '';
    const moduleCode = `// Module\nexports.push([module.id, ${cssAsString}, ""${result.map ? `,${result.map}` : ''}]);\n\n`;
    const exportsCode = exports.length > 0 ? `// Exports\nexports.locals = {\n${exports.join(',\n')}\n};` : ''; // Embed runtime

    return callback(null, runtimeCode + importCode + moduleCode + exportsCode);
  }).catch(error => {
    callback(error.name === 'CssSyntaxError' ? new _CssSyntaxError.default(error) : error);
  });
>>>>>>> 491790fa3284842aea531bfa9d2fd819794b4f37
}